package generic

import (
	"context"
	"fmt"
	"strconv"
	"strings"
	"sync"
	"time"

	cecontext "github.com/cloudevents/sdk-go/v2/context"
	"go.uber.org/zap"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"

	"github.com/stolostron/multicluster-global-hub/agent/pkg/configs"
	"github.com/stolostron/multicluster-global-hub/agent/pkg/status/interfaces"
	"github.com/stolostron/multicluster-global-hub/pkg/constants"
	"github.com/stolostron/multicluster-global-hub/pkg/logger"
	"github.com/stolostron/multicluster-global-hub/pkg/transport"
)

type multiObjectSyncer struct {
	log               *zap.SugaredLogger
	runtimeClient     client.Client
	producer          transport.Producer
	objectControllers []ControllerHandler
	emitter           interfaces.Emitter
	leafHubName       string
	syncIntervalFunc  func() time.Duration
	startOnce         sync.Once

	// share properties with multi-object-controller
	lock *sync.Mutex
}

type ControllerHandler struct {
	interfaces.Controller
	interfaces.Handler
}

// LaunchMultiObjectSyncer send the event generated by multiple object
func LaunchMultiObjectSyncer(name string, mgr ctrl.Manager, objectControllers []ControllerHandler,
	producer transport.Producer, intervalFunc func() time.Duration, emitter interfaces.Emitter,
) error {
	syncer := &multiObjectSyncer{
		log:           logger.ZapLogger(name),
		leafHubName:   configs.GetLeafHubName(),
		runtimeClient: mgr.GetClient(),

		objectControllers: objectControllers,
		emitter:           emitter,
		producer:          producer,
		syncIntervalFunc:  intervalFunc,
		lock:              &sync.Mutex{},
	}

	// start the periodic syncer
	syncer.startOnce.Do(func() {
		go syncer.periodicSync()
	})

	// start all the controllers to update the payload
	for _, eventController := range objectControllers {
		err := AddObjectController(mgr, eventController, emitter, syncer.lock)
		if err != nil {
			return err
		}
	}
	return nil
}

func (s *multiObjectSyncer) periodicSync() {
	currentSyncInterval := s.syncIntervalFunc()
	s.log.Info(fmt.Sprintf("sync interval has been reset to %s", currentSyncInterval.String()))
	ticker := time.NewTicker(currentSyncInterval)
	defer ticker.Stop()

	for {
		s.syncEvent()
		<-ticker.C // wait for next time interval

		resolvedInterval := s.syncIntervalFunc()

		// reset ticker if sync interval has changed
		if resolvedInterval != currentSyncInterval {
			currentSyncInterval = resolvedInterval
			ticker.Reset(currentSyncInterval)
			s.log.Info(fmt.Sprintf("sync interval has been reset to %s", currentSyncInterval.String()))
		}
	}
}

func (s *multiObjectSyncer) syncEvent() {
	s.lock.Lock() // make sure bundles are not updated if we're during bundles sync
	defer s.lock.Unlock()

	// retrieve the bundle from one of the handlers, since they share the same one
	var eventData interface{}
	if len(s.objectControllers) > 0 {
		eventData = s.objectControllers[0].Handler.Get()
	}

	if s.emitter.ShouldSend() {
		evt, err := s.emitter.ToCloudEvent(eventData)
		if err != nil {
			s.log.Error(err, "failed to get CloudEvent instance", "evt", evt)
			return
		}

		ctx := context.TODO()
		if s.emitter.Topic() != "" {
			ctx = cecontext.WithTopic(ctx, s.emitter.Topic())
		}
		if err := s.producer.SendEvent(ctx, *evt); err != nil {
			s.log.Error(err, "failed to send event", "evt", evt)
			return
		}
		s.emitter.PostSend(eventData)
	}
}

const REQUEUE_PERIOD = 5 * time.Second

// single object controller to update the event
type objectController struct {
	log              *zap.SugaredLogger
	client           client.Client
	finalizerName    string
	emitter          interfaces.Emitter
	objectController ControllerHandler

	// objectController interfaces.ObjectController
	lock *sync.Mutex
}

func AddObjectController(mgr ctrl.Manager, objectCtrl ControllerHandler, emitter interfaces.Emitter,
	lock *sync.Mutex,
) error {
	object := objectCtrl.Instance()
	controller := &objectController{
		log:              logger.ZapLogger(fmt.Sprintf("status.%s", object.GetObjectKind())),
		client:           mgr.GetClient(),
		finalizerName:    "",
		emitter:          emitter,
		objectController: objectCtrl,
		lock:             lock,
	}

	controllerBuilder := ctrl.NewControllerManagedBy(mgr).For(object)
	if objectCtrl.Predicate() != nil {
		controllerBuilder = controllerBuilder.WithEventFilter(objectCtrl.Predicate())
	}
	return controllerBuilder.Complete(controller)
}

func (c *objectController) Reconcile(ctx context.Context, request ctrl.Request) (ctrl.Result, error) {
	reqLogger := c.log.With("Namespace", request.Namespace, "Name", request.Name)
	object := c.objectController.Instance()

	if err := c.client.Get(ctx, request.NamespacedName, object); apierrors.IsNotFound(err) {
		// the instance was deleted and it had no finalizer on it.
		// for the local resources, there is no finalizer so we need to delete the object from the bundle
		object.SetNamespace(request.Namespace)
		object.SetName(request.Name)
		if e := c.deleteObjectAndFinalizer(ctx, object); e != nil {
			return ctrl.Result{Requeue: true, RequeueAfter: REQUEUE_PERIOD}, e
		}
		return ctrl.Result{}, nil
	} else if err != nil {
		return ctrl.Result{Requeue: true, RequeueAfter: REQUEUE_PERIOD},
			fmt.Errorf("reconciliation failed: %w", err)
	}

	if !object.GetDeletionTimestamp().IsZero() {
		if err := c.deleteObjectAndFinalizer(ctx, object); err != nil {
			return ctrl.Result{Requeue: true, RequeueAfter: REQUEUE_PERIOD}, err
		}
	} else { // otherwise, the object was not deleted and no error occurred
		if err := c.updateObjectAndFinalizer(ctx, object); err != nil {
			return ctrl.Result{Requeue: true, RequeueAfter: REQUEUE_PERIOD}, err
		}
	}
	reqLogger.Debug("Reconciliation complete.")
	return ctrl.Result{}, nil
}

func (c *objectController) updateObjectAndFinalizer(ctx context.Context, object client.Object) error {
	// only add finalizer for the global resources
	if enableCleanUpFinalizer(object) {
		err := addFinalizer(ctx, c.client, object, c.finalizerName)
		if err != nil {
			return err
		}
	}

	c.lock.Lock() // make sure bundles are not updated if we're during bundles sync
	defer c.lock.Unlock()
	if c.objectController.Update(object) {
		c.emitter.PostUpdate()
	}
	return nil
}

func (c *objectController) deleteObjectAndFinalizer(ctx context.Context, object client.Object) error {
	c.lock.Lock() // make sure bundles are not updated if we're during bundles sync
	if c.objectController.Delete(object) {
		c.emitter.PostUpdate()
	}
	c.lock.Unlock()

	if enableCleanUpFinalizer(object) {
		err := removeFinalizer(ctx, c.client, object, c.finalizerName)
		if err != nil {
			return err
		}
	}
	return nil
}

func enableCleanUpFinalizer(obj client.Object) bool {
	return false
}

func cleanObject(object client.Object) {
	object.SetManagedFields(nil)
	object.SetFinalizers(nil)
	object.SetOwnerReferences(nil)
	object.SetSelfLink("")
	// object.SetClusterName("")
}

func addFinalizer(ctx context.Context, c client.Client, obj client.Object, finalizer string) error {
	// if the removing finalizer label hasn't expired, then skip the adding finalizer action
	if val, found := obj.GetLabels()[constants.GlobalHubFinalizerRemovingDeadline]; found {
		deadline, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return err
		}
		if time.Now().Unix() < deadline {
			return nil
		} else {
			delete(obj.GetLabels(), constants.GlobalHubFinalizerRemovingDeadline)
		}
	}

	if controllerutil.ContainsFinalizer(obj, finalizer) {
		return nil
	}

	controllerutil.AddFinalizer(obj, finalizer)

	if err := c.Update(ctx, obj); err != nil && !strings.Contains(err.Error(), "the object has been modified") {
		return err
	}
	return nil
}

func removeFinalizer(ctx context.Context, c client.Client, obj client.Object, finalizer string) error {
	if !controllerutil.ContainsFinalizer(obj, finalizer) {
		return nil // if finalizer is not there, do nothing.
	}
	controllerutil.RemoveFinalizer(obj, finalizer)

	return c.Update(ctx, obj)
}
